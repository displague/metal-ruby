=begin
#Metal API

#This is the API for Equinix Metal Product. Interact with your devices, user account, and projects.

The version of the OpenAPI document: 1.0.0
Contact: support@equinixmetal.com
Generated by: https://openapi-generator.tech
OpenAPI Generator version: 5.1.0-SNAPSHOT

=end

require 'cgi'

module OpenapiClient
  class DevicesApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Create a BGP session
    # Creates a BGP session.
    # @param id [String] Device UUID
    # @param bgp_session [BGPSessionInput] BGP session to create
    # @param [Hash] opts the optional parameters
    # @return [BgpSession]
    def create_bgp_session(id, bgp_session, opts = {})
      data, _status_code, _headers = create_bgp_session_with_http_info(id, bgp_session, opts)
      data
    end

    # Create a BGP session
    # Creates a BGP session.
    # @param id [String] Device UUID
    # @param bgp_session [BGPSessionInput] BGP session to create
    # @param [Hash] opts the optional parameters
    # @return [Array<(BgpSession, Integer, Hash)>] BgpSession data, response status code and response headers
    def create_bgp_session_with_http_info(id, bgp_session, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.create_bgp_session ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.create_bgp_session"
      end
      # verify the required parameter 'bgp_session' is set
      if @api_client.config.client_side_validation && bgp_session.nil?
        fail ArgumentError, "Missing the required parameter 'bgp_session' when calling DevicesApi.create_bgp_session"
      end
      # resource path
      local_var_path = '/devices/{id}/bgp/sessions'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(bgp_session)

      # return_type
      return_type = opts[:debug_return_type] || 'BgpSession'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.create_bgp_session",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#create_bgp_session\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a device
    # Creates a new device and provisions it in our datacenter.  Type-specific options (such as operating_system for baremetal devices) should be included in the main data structure alongside hostname and plan.  The features attribute allows you to optionally specify what features your server should have.  For example, if you require a server with a TPM chip, you may specify `{ \"features\": { \"tpm\": \"required\" } }` (or `{ \"features\": [\"tpm\"] }` in shorthand).  The request will fail if there are no available servers matching your criteria. Alternatively, if you do not require a certain feature, but would prefer to be assigned a server with that feature if there are any available, you may specify that feature with a preferred value (see the example request below).  The request will not fail if we have no servers with that feature in our inventory.  The facilities attribute specifies in what datacenter you wish to create the device.  You can either specify a single facility `{ \"facility\": \"f1\" }` , or you can instruct to create the device in the best available datacenter `{ \"facility\": \"any\" }`. Additionally it is possible to set a prioritized location selection.  For example `{ \"facility\": [\"f3\", \"f2\", \"any\"] }` will try to assign to the facility f3, if there are no available f2, and so on. If \"any\" is not specified for \"facility\", the request will fail unless it can assign in the selected locations.  The `ip_addresses attribute will allow you to specify the addresses you want created with your device.  To maintain backwards compatibility, If the attribute is not sent in the request, it will be treated as if `{ \"ip_addresses\": [{ \"address_family\": 4, \"public\": true }, { \"address_family\": 4, \"public\": false }, { \"address_family\": 6, \"public\": true }] }` was sent.  The private IPv4 address is required and always need to be sent in the array. Not all operating systems support no public IPv4 address, so in those cases you will receive an error message.  For example, to only configure your server with a private IPv4 address, you can send `{ \"ip_addresses\": [{ \"address_family\": 4, \"public\": false }] }`.  Note: when specifying a subnet size larger than a /30, you will need to supply the UUID(s) of existing ip_reservations in your project to assign IPs from.  For example, `{ \"ip_addresses\": [..., {\"address_family\": 4, \"public\": true, \"ip_reservations\": [\"uuid1\", \"uuid2\"]}] }`  To access a server without public IPs, you can use our Out-of-Band console access (SOS) or use another server with public IPs as a proxy. 
    # @param id [String] Project UUID
    # @param device [DeviceCreateInput] Device to create
    # @param [Hash] opts the optional parameters
    # @return [Device]
    def create_device(id, device, opts = {})
      data, _status_code, _headers = create_device_with_http_info(id, device, opts)
      data
    end

    # Create a device
    # Creates a new device and provisions it in our datacenter.  Type-specific options (such as operating_system for baremetal devices) should be included in the main data structure alongside hostname and plan.  The features attribute allows you to optionally specify what features your server should have.  For example, if you require a server with a TPM chip, you may specify &#x60;{ \&quot;features\&quot;: { \&quot;tpm\&quot;: \&quot;required\&quot; } }&#x60; (or &#x60;{ \&quot;features\&quot;: [\&quot;tpm\&quot;] }&#x60; in shorthand).  The request will fail if there are no available servers matching your criteria. Alternatively, if you do not require a certain feature, but would prefer to be assigned a server with that feature if there are any available, you may specify that feature with a preferred value (see the example request below).  The request will not fail if we have no servers with that feature in our inventory.  The facilities attribute specifies in what datacenter you wish to create the device.  You can either specify a single facility &#x60;{ \&quot;facility\&quot;: \&quot;f1\&quot; }&#x60; , or you can instruct to create the device in the best available datacenter &#x60;{ \&quot;facility\&quot;: \&quot;any\&quot; }&#x60;. Additionally it is possible to set a prioritized location selection.  For example &#x60;{ \&quot;facility\&quot;: [\&quot;f3\&quot;, \&quot;f2\&quot;, \&quot;any\&quot;] }&#x60; will try to assign to the facility f3, if there are no available f2, and so on. If \&quot;any\&quot; is not specified for \&quot;facility\&quot;, the request will fail unless it can assign in the selected locations.  The &#x60;ip_addresses attribute will allow you to specify the addresses you want created with your device.  To maintain backwards compatibility, If the attribute is not sent in the request, it will be treated as if &#x60;{ \&quot;ip_addresses\&quot;: [{ \&quot;address_family\&quot;: 4, \&quot;public\&quot;: true }, { \&quot;address_family\&quot;: 4, \&quot;public\&quot;: false }, { \&quot;address_family\&quot;: 6, \&quot;public\&quot;: true }] }&#x60; was sent.  The private IPv4 address is required and always need to be sent in the array. Not all operating systems support no public IPv4 address, so in those cases you will receive an error message.  For example, to only configure your server with a private IPv4 address, you can send &#x60;{ \&quot;ip_addresses\&quot;: [{ \&quot;address_family\&quot;: 4, \&quot;public\&quot;: false }] }&#x60;.  Note: when specifying a subnet size larger than a /30, you will need to supply the UUID(s) of existing ip_reservations in your project to assign IPs from.  For example, &#x60;{ \&quot;ip_addresses\&quot;: [..., {\&quot;address_family\&quot;: 4, \&quot;public\&quot;: true, \&quot;ip_reservations\&quot;: [\&quot;uuid1\&quot;, \&quot;uuid2\&quot;]}] }&#x60;  To access a server without public IPs, you can use our Out-of-Band console access (SOS) or use another server with public IPs as a proxy. 
    # @param id [String] Project UUID
    # @param device [DeviceCreateInput] Device to create
    # @param [Hash] opts the optional parameters
    # @return [Array<(Device, Integer, Hash)>] Device data, response status code and response headers
    def create_device_with_http_info(id, device, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.create_device ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.create_device"
      end
      # verify the required parameter 'device' is set
      if @api_client.config.client_side_validation && device.nil?
        fail ArgumentError, "Missing the required parameter 'device' when calling DevicesApi.create_device"
      end
      # resource path
      local_var_path = '/projects/{id}/devices'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(device)

      # return_type
      return_type = opts[:debug_return_type] || 'Device'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.create_device",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#create_device\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a devices batch
    # Creates new devices in batch and provisions them in our datacenter.  Type-specific options (such as operating_system for baremetal devices) should be included in the main data structure alongside hostname and plan.  The features attribute allows you to optionally specify what features your server should have.  For example, if you require a server with a TPM chip, you may specify `{ \"features\": { \"tpm\": \"required\" } }` (or `{ \"features\": [\"tpm\"] }` in shorthand).  The request will fail if there are no available servers matching your criteria. Alternatively, if you do not require a certain feature, but would prefer to be assigned a server with that feature if there are any available, you may specify that feature with a preferred value (see the example request below).  The request will not fail if we have no servers with that feature in our inventory.  The facilities attribute specifies in what datacenter you wish to create the device.  You can either specify a single facility `{ \"facility\": \"f1\" }` , or you can instruct to create the device in the best available datacenter `{ \"facility\": \"any\" }`. Additionally it is possible to set a prioritized location selection.  For example `{ \"facility\": [\"f3\", \"f2\", \"any\"] }` will try to assign to the facility f3, if there are no available f2, and so on. If \"any\" is not specified for \"facility\", the request will fail unless it can assign in the selected locations.  With `{ \"facility\": \"any\" }` you have the option to diversify to indicate how many facilities you are willing to be spread across. For this purpose use parameter: `facility_diversity_level = N`.  For example:  `{ \"facilities\": [\"sjc1\", \"ewr1\", \"any\"] ,  \"facility_diversity_level\" = 1, \"quantity\" = 10 }` will assign 10 devices into the same facility, trying first in \"sjc1\", and if there aren’t available, it will try in  \"ewr1\", otherwise any other.  The `ip_addresses` attribute will allow you to specify the addresses you want created with your device.  To maintain backwards compatibility, If the attribute is not sent in the request, it will be treated as if `{ \"ip_addresses\": [{ \"address_family\": 4, \"public\": true }, { \"address_family\": 4, \"public\": false }, { \"address_family\": 6, \"public\": true }] }` was sent.  The private IPv4 address is required and always need to be sent in the array. Not all operating systems support no public IPv4 address, so in those cases you will receive an error message.  For example, to only configure your server with a private IPv4 address, you can send `{ \"ip_addresses\": [{ \"address_family\": 4, \"public\": false }] }`.  Note: when specifying a subnet size larger than a /30, you will need to supply the UUID(s) of existing ip_reservations in your project to assign IPs from.  For example, `{ \"ip_addresses\": [..., {\"address_family\": 4, \"public\": true, \"ip_reservations\": [\"uuid1\", \"uuid2\"]}] }`  To access a server without public IPs, you can use our Out-of-Band console access (SOS) or use another server with public IPs as a proxy.
    # @param id [String] Project UUID
    # @param batch [InstancesBatchCreateInput] Batches to create
    # @param [Hash] opts the optional parameters
    # @return [BatchesList]
    def create_device_batch(id, batch, opts = {})
      data, _status_code, _headers = create_device_batch_with_http_info(id, batch, opts)
      data
    end

    # Create a devices batch
    # Creates new devices in batch and provisions them in our datacenter.  Type-specific options (such as operating_system for baremetal devices) should be included in the main data structure alongside hostname and plan.  The features attribute allows you to optionally specify what features your server should have.  For example, if you require a server with a TPM chip, you may specify &#x60;{ \&quot;features\&quot;: { \&quot;tpm\&quot;: \&quot;required\&quot; } }&#x60; (or &#x60;{ \&quot;features\&quot;: [\&quot;tpm\&quot;] }&#x60; in shorthand).  The request will fail if there are no available servers matching your criteria. Alternatively, if you do not require a certain feature, but would prefer to be assigned a server with that feature if there are any available, you may specify that feature with a preferred value (see the example request below).  The request will not fail if we have no servers with that feature in our inventory.  The facilities attribute specifies in what datacenter you wish to create the device.  You can either specify a single facility &#x60;{ \&quot;facility\&quot;: \&quot;f1\&quot; }&#x60; , or you can instruct to create the device in the best available datacenter &#x60;{ \&quot;facility\&quot;: \&quot;any\&quot; }&#x60;. Additionally it is possible to set a prioritized location selection.  For example &#x60;{ \&quot;facility\&quot;: [\&quot;f3\&quot;, \&quot;f2\&quot;, \&quot;any\&quot;] }&#x60; will try to assign to the facility f3, if there are no available f2, and so on. If \&quot;any\&quot; is not specified for \&quot;facility\&quot;, the request will fail unless it can assign in the selected locations.  With &#x60;{ \&quot;facility\&quot;: \&quot;any\&quot; }&#x60; you have the option to diversify to indicate how many facilities you are willing to be spread across. For this purpose use parameter: &#x60;facility_diversity_level &#x3D; N&#x60;.  For example:  &#x60;{ \&quot;facilities\&quot;: [\&quot;sjc1\&quot;, \&quot;ewr1\&quot;, \&quot;any\&quot;] ,  \&quot;facility_diversity_level\&quot; &#x3D; 1, \&quot;quantity\&quot; &#x3D; 10 }&#x60; will assign 10 devices into the same facility, trying first in \&quot;sjc1\&quot;, and if there aren’t available, it will try in  \&quot;ewr1\&quot;, otherwise any other.  The &#x60;ip_addresses&#x60; attribute will allow you to specify the addresses you want created with your device.  To maintain backwards compatibility, If the attribute is not sent in the request, it will be treated as if &#x60;{ \&quot;ip_addresses\&quot;: [{ \&quot;address_family\&quot;: 4, \&quot;public\&quot;: true }, { \&quot;address_family\&quot;: 4, \&quot;public\&quot;: false }, { \&quot;address_family\&quot;: 6, \&quot;public\&quot;: true }] }&#x60; was sent.  The private IPv4 address is required and always need to be sent in the array. Not all operating systems support no public IPv4 address, so in those cases you will receive an error message.  For example, to only configure your server with a private IPv4 address, you can send &#x60;{ \&quot;ip_addresses\&quot;: [{ \&quot;address_family\&quot;: 4, \&quot;public\&quot;: false }] }&#x60;.  Note: when specifying a subnet size larger than a /30, you will need to supply the UUID(s) of existing ip_reservations in your project to assign IPs from.  For example, &#x60;{ \&quot;ip_addresses\&quot;: [..., {\&quot;address_family\&quot;: 4, \&quot;public\&quot;: true, \&quot;ip_reservations\&quot;: [\&quot;uuid1\&quot;, \&quot;uuid2\&quot;]}] }&#x60;  To access a server without public IPs, you can use our Out-of-Band console access (SOS) or use another server with public IPs as a proxy.
    # @param id [String] Project UUID
    # @param batch [InstancesBatchCreateInput] Batches to create
    # @param [Hash] opts the optional parameters
    # @return [Array<(BatchesList, Integer, Hash)>] BatchesList data, response status code and response headers
    def create_device_batch_with_http_info(id, batch, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.create_device_batch ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.create_device_batch"
      end
      # verify the required parameter 'batch' is set
      if @api_client.config.client_side_validation && batch.nil?
        fail ArgumentError, "Missing the required parameter 'batch' when calling DevicesApi.create_device_batch"
      end
      # resource path
      local_var_path = '/projects/{id}/devices/batch'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(batch)

      # return_type
      return_type = opts[:debug_return_type] || 'BatchesList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.create_device_batch",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#create_device_batch\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a ip assignment
    # Creates an ip assignment for a device.
    # @param id [String] Device UUID
    # @param ip_assignment [IPAssignmentInput] IPAssignment to create
    # @param [Hash] opts the optional parameters
    # @return [IPAssignment]
    def create_ip_assignment(id, ip_assignment, opts = {})
      data, _status_code, _headers = create_ip_assignment_with_http_info(id, ip_assignment, opts)
      data
    end

    # Create a ip assignment
    # Creates an ip assignment for a device.
    # @param id [String] Device UUID
    # @param ip_assignment [IPAssignmentInput] IPAssignment to create
    # @param [Hash] opts the optional parameters
    # @return [Array<(IPAssignment, Integer, Hash)>] IPAssignment data, response status code and response headers
    def create_ip_assignment_with_http_info(id, ip_assignment, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.create_ip_assignment ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.create_ip_assignment"
      end
      # verify the required parameter 'ip_assignment' is set
      if @api_client.config.client_side_validation && ip_assignment.nil?
        fail ArgumentError, "Missing the required parameter 'ip_assignment' when calling DevicesApi.create_ip_assignment"
      end
      # resource path
      local_var_path = '/devices/{id}/ips'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(ip_assignment)

      # return_type
      return_type = opts[:debug_return_type] || 'IPAssignment'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.create_ip_assignment",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#create_ip_assignment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete the device
    # Deletes a device and deprovisions it in our datacenter.
    # @param id [String] Device UUID
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :force_delete Force the deletion of the device, by detaching any storage volume still active.
    # @return [nil]
    def delete_device(id, opts = {})
      delete_device_with_http_info(id, opts)
      nil
    end

    # Delete the device
    # Deletes a device and deprovisions it in our datacenter.
    # @param id [String] Device UUID
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :force_delete Force the deletion of the device, by detaching any storage volume still active.
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def delete_device_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.delete_device ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.delete_device"
      end
      # resource path
      local_var_path = '/devices/{id}'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'force_delete'] = opts[:'force_delete'] if !opts[:'force_delete'].nil?

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.delete_device",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#delete_device\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve all BGP sessions
    # Provides a listing of available BGP sessions for the device.
    # @param id [String] Device UUID
    # @param [Hash] opts the optional parameters
    # @return [BgpSessionList]
    def find_bgp_sessions(id, opts = {})
      data, _status_code, _headers = find_bgp_sessions_with_http_info(id, opts)
      data
    end

    # Retrieve all BGP sessions
    # Provides a listing of available BGP sessions for the device.
    # @param id [String] Device UUID
    # @param [Hash] opts the optional parameters
    # @return [Array<(BgpSessionList, Integer, Hash)>] BgpSessionList data, response status code and response headers
    def find_bgp_sessions_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.find_bgp_sessions ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.find_bgp_sessions"
      end
      # resource path
      local_var_path = '/devices/{id}/bgp/sessions'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'BgpSessionList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.find_bgp_sessions",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#find_bgp_sessions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a device
    # Type-specific options (such as facility for baremetal devices) will be included as part of the main data structure.                          State value can be one of: active inactive queued or provisioning
    # @param id [String] Device UUID
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :include Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
    # @option opts [Array<String>] :exclude Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
    # @return [Device]
    def find_device_by_id(id, opts = {})
      data, _status_code, _headers = find_device_by_id_with_http_info(id, opts)
      data
    end

    # Retrieve a device
    # Type-specific options (such as facility for baremetal devices) will be included as part of the main data structure.                          State value can be one of: active inactive queued or provisioning
    # @param id [String] Device UUID
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :include Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
    # @option opts [Array<String>] :exclude Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
    # @return [Array<(Device, Integer, Hash)>] Device data, response status code and response headers
    def find_device_by_id_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.find_device_by_id ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.find_device_by_id"
      end
      # resource path
      local_var_path = '/devices/{id}'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'include'] = @api_client.build_collection_param(opts[:'include'], :csv) if !opts[:'include'].nil?
      query_params[:'exclude'] = @api_client.build_collection_param(opts[:'exclude'], :csv) if !opts[:'exclude'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Device'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.find_device_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#find_device_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve the custom metadata of an instance
    # Provides the custom metadata stored for this instance in json format
    # @param id [String] Instance UUID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def find_device_customdata(id, opts = {})
      find_device_customdata_with_http_info(id, opts)
      nil
    end

    # Retrieve the custom metadata of an instance
    # Provides the custom metadata stored for this instance in json format
    # @param id [String] Instance UUID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def find_device_customdata_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.find_device_customdata ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.find_device_customdata"
      end
      # resource path
      local_var_path = '/devices/{id}/customdata'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.find_device_customdata",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#find_device_customdata\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve device's events
    # Returns a list of events pertaining to a specific device
    # @param id [String] Device UUID
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :include Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
    # @option opts [Array<String>] :exclude Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
    # @option opts [Integer] :page Page to return (default to 1)
    # @option opts [Integer] :per_page Items returned per page (default to 10)
    # @return [EventList]
    def find_device_events(id, opts = {})
      data, _status_code, _headers = find_device_events_with_http_info(id, opts)
      data
    end

    # Retrieve device&#39;s events
    # Returns a list of events pertaining to a specific device
    # @param id [String] Device UUID
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :include Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
    # @option opts [Array<String>] :exclude Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
    # @option opts [Integer] :page Page to return
    # @option opts [Integer] :per_page Items returned per page
    # @return [Array<(EventList, Integer, Hash)>] EventList data, response status code and response headers
    def find_device_events_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.find_device_events ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.find_device_events"
      end
      if @api_client.config.client_side_validation && !opts[:'page'].nil? && opts[:'page'] > 100000
        fail ArgumentError, 'invalid value for "opts[:"page"]" when calling DevicesApi.find_device_events, must be smaller than or equal to 100000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page'].nil? && opts[:'page'] < 1
        fail ArgumentError, 'invalid value for "opts[:"page"]" when calling DevicesApi.find_device_events, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'per_page'].nil? && opts[:'per_page'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"per_page"]" when calling DevicesApi.find_device_events, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'per_page'].nil? && opts[:'per_page'] < 1
        fail ArgumentError, 'invalid value for "opts[:"per_page"]" when calling DevicesApi.find_device_events, must be greater than or equal to 1.'
      end

      # resource path
      local_var_path = '/devices/{id}/events'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'include'] = @api_client.build_collection_param(opts[:'include'], :csv) if !opts[:'include'].nil?
      query_params[:'exclude'] = @api_client.build_collection_param(opts[:'exclude'], :csv) if !opts[:'exclude'].nil?
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?
      query_params[:'per_page'] = opts[:'per_page'] if !opts[:'per_page'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'EventList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.find_device_events",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#find_device_events\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve all usages for device
    # Returns all usages for a device.
    # @param id [String] Device UUID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :created_after Filter usages created after this date
    # @option opts [String] :created_before Filter usages created before this date
    # @return [DeviceUsageList]
    def find_device_usages(id, opts = {})
      data, _status_code, _headers = find_device_usages_with_http_info(id, opts)
      data
    end

    # Retrieve all usages for device
    # Returns all usages for a device.
    # @param id [String] Device UUID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :created_after Filter usages created after this date
    # @option opts [String] :created_before Filter usages created before this date
    # @return [Array<(DeviceUsageList, Integer, Hash)>] DeviceUsageList data, response status code and response headers
    def find_device_usages_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.find_device_usages ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.find_device_usages"
      end
      # resource path
      local_var_path = '/devices/{id}/usages'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'created[after]'] = opts[:'created_after'] if !opts[:'created_after'].nil?
      query_params[:'created[before]'] = opts[:'created_before'] if !opts[:'created_before'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DeviceUsageList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.find_device_usages",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#find_device_usages\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve an instance bandwidth
    # Retrieve an instance bandwidth for a given period of time.
    # @param id [String] Device UUID
    # @param from [String] Timestamp from range
    # @param _until [String] Timestamp to range
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def find_instance_bandwidth(id, from, _until, opts = {})
      find_instance_bandwidth_with_http_info(id, from, _until, opts)
      nil
    end

    # Retrieve an instance bandwidth
    # Retrieve an instance bandwidth for a given period of time.
    # @param id [String] Device UUID
    # @param from [String] Timestamp from range
    # @param _until [String] Timestamp to range
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def find_instance_bandwidth_with_http_info(id, from, _until, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.find_instance_bandwidth ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.find_instance_bandwidth"
      end
      # verify the required parameter 'from' is set
      if @api_client.config.client_side_validation && from.nil?
        fail ArgumentError, "Missing the required parameter 'from' when calling DevicesApi.find_instance_bandwidth"
      end
      # verify the required parameter '_until' is set
      if @api_client.config.client_side_validation && _until.nil?
        fail ArgumentError, "Missing the required parameter '_until' when calling DevicesApi.find_instance_bandwidth"
      end
      # resource path
      local_var_path = '/devices/{id}/bandwidth'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'from'] = from
      query_params[:'until'] = _until

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.find_instance_bandwidth",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#find_instance_bandwidth\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve the custom metadata of an IP Assignment
    # Provides the custom metadata stored for this IP Assignment in json format
    # @param instance_id [String] Instance UUID
    # @param id [String] Ip Assignment UUID
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def find_ip_assignment_customdata(instance_id, id, opts = {})
      find_ip_assignment_customdata_with_http_info(instance_id, id, opts)
      nil
    end

    # Retrieve the custom metadata of an IP Assignment
    # Provides the custom metadata stored for this IP Assignment in json format
    # @param instance_id [String] Instance UUID
    # @param id [String] Ip Assignment UUID
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def find_ip_assignment_customdata_with_http_info(instance_id, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.find_ip_assignment_customdata ...'
      end
      # verify the required parameter 'instance_id' is set
      if @api_client.config.client_side_validation && instance_id.nil?
        fail ArgumentError, "Missing the required parameter 'instance_id' when calling DevicesApi.find_ip_assignment_customdata"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.find_ip_assignment_customdata"
      end
      # resource path
      local_var_path = '/devices/{instance_id}/ips/{id}/customdata'.sub('{' + 'instance_id' + '}', CGI.escape(instance_id.to_s)).sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.find_ip_assignment_customdata",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#find_ip_assignment_customdata\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve all ip assignments
    # Returns all ip assignments for a device.
    # @param id [String] Device UUID
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :include Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
    # @option opts [Array<String>] :exclude Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
    # @return [IPAssignmentList]
    def find_ip_assignments(id, opts = {})
      data, _status_code, _headers = find_ip_assignments_with_http_info(id, opts)
      data
    end

    # Retrieve all ip assignments
    # Returns all ip assignments for a device.
    # @param id [String] Device UUID
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :include Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
    # @option opts [Array<String>] :exclude Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
    # @return [Array<(IPAssignmentList, Integer, Hash)>] IPAssignmentList data, response status code and response headers
    def find_ip_assignments_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.find_ip_assignments ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.find_ip_assignments"
      end
      # resource path
      local_var_path = '/devices/{id}/ips'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'include'] = @api_client.build_collection_param(opts[:'include'], :csv) if !opts[:'include'].nil?
      query_params[:'exclude'] = @api_client.build_collection_param(opts[:'exclude'], :csv) if !opts[:'exclude'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'IPAssignmentList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.find_ip_assignments",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#find_ip_assignments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve all devices of an organization
    # Provides a collection of devices for a given organization.
    # @param id [String] Organization UUID
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :include Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
    # @option opts [Array<String>] :exclude Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
    # @option opts [Integer] :page Page to return (default to 1)
    # @option opts [Integer] :per_page Items returned per page (default to 10)
    # @return [DeviceList]
    def find_organization_devices(id, opts = {})
      data, _status_code, _headers = find_organization_devices_with_http_info(id, opts)
      data
    end

    # Retrieve all devices of an organization
    # Provides a collection of devices for a given organization.
    # @param id [String] Organization UUID
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :include Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
    # @option opts [Array<String>] :exclude Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
    # @option opts [Integer] :page Page to return
    # @option opts [Integer] :per_page Items returned per page
    # @return [Array<(DeviceList, Integer, Hash)>] DeviceList data, response status code and response headers
    def find_organization_devices_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.find_organization_devices ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.find_organization_devices"
      end
      if @api_client.config.client_side_validation && !opts[:'page'].nil? && opts[:'page'] > 100000
        fail ArgumentError, 'invalid value for "opts[:"page"]" when calling DevicesApi.find_organization_devices, must be smaller than or equal to 100000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page'].nil? && opts[:'page'] < 1
        fail ArgumentError, 'invalid value for "opts[:"page"]" when calling DevicesApi.find_organization_devices, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'per_page'].nil? && opts[:'per_page'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"per_page"]" when calling DevicesApi.find_organization_devices, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'per_page'].nil? && opts[:'per_page'] < 1
        fail ArgumentError, 'invalid value for "opts[:"per_page"]" when calling DevicesApi.find_organization_devices, must be greater than or equal to 1.'
      end

      # resource path
      local_var_path = '/organizations/{id}/devices'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'include'] = @api_client.build_collection_param(opts[:'include'], :csv) if !opts[:'include'].nil?
      query_params[:'exclude'] = @api_client.build_collection_param(opts[:'exclude'], :csv) if !opts[:'exclude'].nil?
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?
      query_params[:'per_page'] = opts[:'per_page'] if !opts[:'per_page'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DeviceList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.find_organization_devices",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#find_organization_devices\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve all devices of a project
    # Provides a collection of devices for a given project.
    # @param id [String] Project UUID
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :include Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
    # @option opts [Array<String>] :exclude Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
    # @option opts [Integer] :page Page to return (default to 1)
    # @option opts [Integer] :per_page Items returned per page (default to 10)
    # @return [DeviceList]
    def find_project_devices(id, opts = {})
      data, _status_code, _headers = find_project_devices_with_http_info(id, opts)
      data
    end

    # Retrieve all devices of a project
    # Provides a collection of devices for a given project.
    # @param id [String] Project UUID
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :include Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
    # @option opts [Array<String>] :exclude Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
    # @option opts [Integer] :page Page to return
    # @option opts [Integer] :per_page Items returned per page
    # @return [Array<(DeviceList, Integer, Hash)>] DeviceList data, response status code and response headers
    def find_project_devices_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.find_project_devices ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.find_project_devices"
      end
      if @api_client.config.client_side_validation && !opts[:'page'].nil? && opts[:'page'] > 100000
        fail ArgumentError, 'invalid value for "opts[:"page"]" when calling DevicesApi.find_project_devices, must be smaller than or equal to 100000.'
      end

      if @api_client.config.client_side_validation && !opts[:'page'].nil? && opts[:'page'] < 1
        fail ArgumentError, 'invalid value for "opts[:"page"]" when calling DevicesApi.find_project_devices, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'per_page'].nil? && opts[:'per_page'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"per_page"]" when calling DevicesApi.find_project_devices, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'per_page'].nil? && opts[:'per_page'] < 1
        fail ArgumentError, 'invalid value for "opts[:"per_page"]" when calling DevicesApi.find_project_devices, must be greater than or equal to 1.'
      end

      # resource path
      local_var_path = '/projects/{id}/devices'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'include'] = @api_client.build_collection_param(opts[:'include'], :csv) if !opts[:'include'].nil?
      query_params[:'exclude'] = @api_client.build_collection_param(opts[:'exclude'], :csv) if !opts[:'exclude'].nil?
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?
      query_params[:'per_page'] = opts[:'per_page'] if !opts[:'per_page'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DeviceList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.find_project_devices",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#find_project_devices\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve all usages for project
    # Returns all usages for a project.
    # @param id [String] Project UUID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :created_after Filter usages created after this date
    # @option opts [String] :created_before Filter usages created before this date
    # @return [ProjectUsageList]
    def find_project_usage(id, opts = {})
      data, _status_code, _headers = find_project_usage_with_http_info(id, opts)
      data
    end

    # Retrieve all usages for project
    # Returns all usages for a project.
    # @param id [String] Project UUID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :created_after Filter usages created after this date
    # @option opts [String] :created_before Filter usages created before this date
    # @return [Array<(ProjectUsageList, Integer, Hash)>] ProjectUsageList data, response status code and response headers
    def find_project_usage_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.find_project_usage ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.find_project_usage"
      end
      # resource path
      local_var_path = '/projects/{id}/usages'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'created[after]'] = opts[:'created_after'] if !opts[:'created_after'].nil?
      query_params[:'created[before]'] = opts[:'created_before'] if !opts[:'created_before'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProjectUsageList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.find_project_usage",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#find_project_usage\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve device traffic
    # Returns traffic for a specific device.
    # @param id [String] Device UUID
    # @param direction [String] Traffic direction
    # @param timeframe [Timeframe] Traffic timeframe
    # @param [Hash] opts the optional parameters
    # @option opts [String] :interval Traffic interval
    # @option opts [String] :bucket Traffic bucket
    # @return [nil]
    def find_traffic(id, direction, timeframe, opts = {})
      find_traffic_with_http_info(id, direction, timeframe, opts)
      nil
    end

    # Retrieve device traffic
    # Returns traffic for a specific device.
    # @param id [String] Device UUID
    # @param direction [String] Traffic direction
    # @param timeframe [Timeframe] Traffic timeframe
    # @param [Hash] opts the optional parameters
    # @option opts [String] :interval Traffic interval
    # @option opts [String] :bucket Traffic bucket
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def find_traffic_with_http_info(id, direction, timeframe, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.find_traffic ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.find_traffic"
      end
      # verify the required parameter 'direction' is set
      if @api_client.config.client_side_validation && direction.nil?
        fail ArgumentError, "Missing the required parameter 'direction' when calling DevicesApi.find_traffic"
      end
      # verify enum value
      allowable_values = ["inbound", "outbound"]
      if @api_client.config.client_side_validation && !allowable_values.include?(direction)
        fail ArgumentError, "invalid value for \"direction\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'timeframe' is set
      if @api_client.config.client_side_validation && timeframe.nil?
        fail ArgumentError, "Missing the required parameter 'timeframe' when calling DevicesApi.find_traffic"
      end
      allowable_values = ["minute", "hour", "day", "week", "month", "year", "hour_of_day", "day_of_week", "day_of_month", "month_of_year"]
      if @api_client.config.client_side_validation && opts[:'interval'] && !allowable_values.include?(opts[:'interval'])
        fail ArgumentError, "invalid value for \"interval\", must be one of #{allowable_values}"
      end
      allowable_values = ["internal", "external"]
      if @api_client.config.client_side_validation && opts[:'bucket'] && !allowable_values.include?(opts[:'bucket'])
        fail ArgumentError, "invalid value for \"bucket\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/devices/{id}/traffic'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'direction'] = direction
      query_params[:'interval'] = opts[:'interval'] if !opts[:'interval'].nil?
      query_params[:'bucket'] = opts[:'bucket'] if !opts[:'bucket'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(timeframe)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.find_traffic",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#find_traffic\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve BGP neighbor data for this device
    # Provides a summary of the BGP neighbor data associated to the BGP sessions for this device.
    # @param id [String] Device UUID
    # @param [Hash] opts the optional parameters
    # @return [BgpSessionNeighbors]
    def get_bgp_neighbor_data(id, opts = {})
      data, _status_code, _headers = get_bgp_neighbor_data_with_http_info(id, opts)
      data
    end

    # Retrieve BGP neighbor data for this device
    # Provides a summary of the BGP neighbor data associated to the BGP sessions for this device.
    # @param id [String] Device UUID
    # @param [Hash] opts the optional parameters
    # @return [Array<(BgpSessionNeighbors, Integer, Hash)>] BgpSessionNeighbors data, response status code and response headers
    def get_bgp_neighbor_data_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.get_bgp_neighbor_data ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.get_bgp_neighbor_data"
      end
      # resource path
      local_var_path = '/devices/{id}/bgp/neighbors'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'BgpSessionNeighbors'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.get_bgp_neighbor_data",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#get_bgp_neighbor_data\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Perform an action
    # Performs an action for the given device.  Possible actions include: power_on, power_off, reboot, reinstall, and rescue (reboot the device into rescue OS.)
    # @param id [String] Device UUID
    # @param type [String] Action to perform
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def perform_action(id, type, opts = {})
      perform_action_with_http_info(id, type, opts)
      nil
    end

    # Perform an action
    # Performs an action for the given device.  Possible actions include: power_on, power_off, reboot, reinstall, and rescue (reboot the device into rescue OS.)
    # @param id [String] Device UUID
    # @param type [String] Action to perform
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def perform_action_with_http_info(id, type, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.perform_action ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.perform_action"
      end
      # verify the required parameter 'type' is set
      if @api_client.config.client_side_validation && type.nil?
        fail ArgumentError, "Missing the required parameter 'type' when calling DevicesApi.perform_action"
      end
      # verify enum value
      allowable_values = ["power_on", "power_off", "reboot", "rescue", "reinstall"]
      if @api_client.config.client_side_validation && !allowable_values.include?(type)
        fail ArgumentError, "invalid value for \"type\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/devices/{id}/actions'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'type'] = type

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.perform_action",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#perform_action\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update the device
    # Updates the device.
    # @param id [String] Device UUID
    # @param device [DeviceUpdateInput] Facility to update
    # @param [Hash] opts the optional parameters
    # @return [Device]
    def update_device(id, device, opts = {})
      data, _status_code, _headers = update_device_with_http_info(id, device, opts)
      data
    end

    # Update the device
    # Updates the device.
    # @param id [String] Device UUID
    # @param device [DeviceUpdateInput] Facility to update
    # @param [Hash] opts the optional parameters
    # @return [Array<(Device, Integer, Hash)>] Device data, response status code and response headers
    def update_device_with_http_info(id, device, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevicesApi.update_device ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DevicesApi.update_device"
      end
      # verify the required parameter 'device' is set
      if @api_client.config.client_side_validation && device.nil?
        fail ArgumentError, "Missing the required parameter 'device' when calling DevicesApi.update_device"
      end
      # resource path
      local_var_path = '/devices/{id}'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(device)

      # return_type
      return_type = opts[:debug_return_type] || 'Device'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['x_auth_token']

      new_options = opts.merge(
        :operation => :"DevicesApi.update_device",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevicesApi#update_device\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
